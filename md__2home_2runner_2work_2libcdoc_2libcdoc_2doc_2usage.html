<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libcdoc: Basic libcdoc usage</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">libcdoc<span id="projectnumber">&#160;0.1.5</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__2home_2runner_2work_2libcdoc_2libcdoc_2doc_2usage.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Basic libcdoc usage</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md0"></a> </p>
<h1><a class="anchor" id="autotoc_md1"></a>
Common</h1>
<p>Most methods return result_t status value. It can be one of the following:</p>
<ul>
<li>positive value - for read and write methods indicates success and the number of bytes read/written</li>
<li>OK (= 0) - indicates success</li>
<li>END_OF_STREAM (= -1) - indicates the end of file list in multi-file source</li>
<li>any error value (&lt; -1) - failure</li>
</ul>
<p>The END_OF_STREAM can only be returned from nextFile methods. For all other methods any negative value is always an error.</p>
<h1><a class="anchor" id="autotoc_md2"></a>
Encryption</h1>
<p>The encryption is managed by CDocWriter object.</p>
<h2><a class="anchor" id="autotoc_md3"></a>
CryptoBackend</h2>
<p>Create or implement a CryptoBackend class. The default implementation is enough for public key encryption schemes, to use symmetric keys, at least one of the following methods has to be implemented: </p><pre class="fragment">int getSecret(std::vector&lt;uint8_t&gt;&amp; dst, unsigned int idx)
</pre><p> It should return (in dst vector) either the password (for PBKDF based keys) or plain AES key. It is the simplest method, but potentially exposes password or key in memory. </p><pre class="fragment">int getKeyMaterial(std::vector&lt;uint8_t&gt;&amp; dst, const std::vector&lt;uint8_t&gt;&amp; pw_salt, int32_t kdf_iter, unsigned int idx)
</pre><p> It should return the key material for a symmetric key (either password or plain key) derivation. The default implementation calls getSecret and performs PBKDF2_SHA256 if key is password-based. </p><pre class="fragment">extractHKDF(std::vector&lt;uint8_t&gt;&amp; dst, const std::vector&lt;uint8_t&gt;&amp; salt, const std::vector&lt;uint8_t&gt;&amp; pw_salt, int32_t kdf_iter, unsigned int idx)
</pre><p> It should calculate KEK (Key Encryption Key) pre-master from a symmetric key (either password or key-based). The default implementation calls getKeyMaterial and performs local HKDF extract.</p>
<h2><a class="anchor" id="autotoc_md4"></a>
NetworkBackend</h2>
<p>If the user intends to use keyserver, a NetworkBackend has to be subclassed with the following method implementations: </p><pre class="fragment">int getClientTLSCertificate(std::vector&lt;uint8_t&gt;&amp; dst)
</pre><p> Return the client TLS for authentication to the keyserver </p><pre class="fragment">int getPeerTLSCertificates(std::vector&lt;std::vector&lt;uint8_t&gt;&gt; &amp;dst)
</pre><p> Return the list of acceptable peer sertificates of the keyserver </p><pre class="fragment">int signTLS(std::vector&lt;uint8_t&gt;&amp; dst, CryptoBackend::HashAlgorithm algorithm, const std::vector&lt;uint8_t&gt; &amp;digest)
</pre><p> Sign method for TLS authentication</p>
<p>In addition to NetworkBackend methods, a Configuration subclass has to be created</p>
<h2><a class="anchor" id="autotoc_md5"></a>
Configuration</h2>
<p>It is needed to get keyserver parameters. Subclass has to implement the following method: </p><pre class="fragment">std::string getValue(const std::string_view&amp; domain, const std::string_view&amp; param)
</pre><p> It returns configuration value for domain/param combination. For keyserver:</p>
<ul>
<li>domain is the keyserver id</li>
<li>param is KEYSERVER_SEND_URL</li>
</ul>
<h2><a class="anchor" id="autotoc_md6"></a>
CDocWriter</h2>
<p>CDocWriter should be created with one of the static constructors: </p><pre class="fragment">CDocWriter *createWriter(int version, DataConsumer *dst, bool take_ownership, Configuration *conf, CryptoBackend *crypto, NetworkBackend *network)
CDocWriter *createWriter(int version, std::ostream&amp; ofs, Configuration *conf, CryptoBackend *crypto, NetworkBackend *network)
CDocWriter *createWriter(int version, const std::string&amp; path, Configuration *conf, CryptoBackend *crypto, NetworkBackend *network)
</pre><p> Version is 1 or 2 (indicates the file format used).</p>
<p>CryptoBackend has to be supplied, NetworkBackend and Configuration may be nullptr if keyserver is not used. CDocWriter does not take ownership of these objects, so they should be deleted by caller.</p>
<p>Add one or more recipients: </p><pre class="fragment">int addRecipient(const Recipient&amp; rcpt)
</pre><p> Start the encryption workflow: </p><pre class="fragment">int beginEncryption()
</pre><p> Write one or more files: </p><pre class="fragment">int addFile(const std::string&amp; name, size_t size)
int64_t writeData(const uint8_t *src, size_t size)
</pre><p> Finish encryption: </p><pre class="fragment">int finishEncryption()
</pre> <h2><a class="anchor" id="autotoc_md7"></a>
TLDR</h2>
<pre class="fragment">struct MyBackend : public libcdoc::CryptoBackend {
    /* Only needed for symmetric keys */
    int getSecret(std::vector&lt;uint8_t&gt;&amp; dst, unsigned int idx) override final {
        /* Write secret to dst */
    }
}

/* In the data processing method */
MyBackend crypto;

CDocWriter *writer = createWriter(version, cdoc_filename, nullptr, &amp;crypto, nullptr);
/* For each recipient */
    writer-&gt;addRecipient(myrcpt);
writer-&gt;beginEncryption();
/* For each file */
    writer-&gt;addFile(filename, -1);
    writer-&gt;writeData(data, data_size);

writer-&gt;finishEncryption();

delete writer;
</pre> <h1><a class="anchor" id="autotoc_md8"></a>
Decryption</h1>
<p>Decryption is managed by CDocReader object</p>
<h2><a class="anchor" id="autotoc_md9"></a>
CryptoBackend</h2>
<p>Create or implement a CryptoBackend class. To decrypt all lock types, at least the following methods have to be implemented: </p><pre class="fragment">int deriveECDH1(std::vector&lt;uint8_t&gt;&amp; dst, const std::vector&lt;uint8_t&gt; &amp;public_key, unsigned int idx)
</pre><p> Derives a shared secret from document public key and recipient's private key using ECDH1 algorithm. </p><pre class="fragment">int decryptRSA(std::vector&lt;uint8_t&gt;&amp; dst, const std::vector&lt;uint8_t&gt;&amp; data, bool oaep, unsigned int idx)
</pre><p> Decrypts data using RSA private key.</p>
<p>Also one of the symmetric key methods listed in encryption section for symmetric key support.</p>
<h2><a class="anchor" id="autotoc_md10"></a>
NetworkBackend</h2>
<p>It has to be implemented and supplied if server-based capsules are needed.</p>
<h2><a class="anchor" id="autotoc_md11"></a>
Configuration</h2>
<p>To decrypt server capsules, configuration has to contain the value of the following entry (domain is keyserver id as in encryption):</p>
<ul>
<li>KEYSERVER_FETCH_URL</li>
</ul>
<h2><a class="anchor" id="autotoc_md12"></a>
CDocReader</h2>
<p>Whether or not a file or DataSource is CDoc container can be determined by the following methods: </p><pre class="fragment">int getCDocFileVersion(const std::string&amp; path);
int getCDocFileVersion(DataSource *src);
</pre><p> Both return either the container version (1 or 2) or a negative number if the file/source is not valid container.</p>
<p>CDocReader has to be created with one of the following static constructors: </p><pre class="fragment">CDocReader *createReader(DataSource *src, bool take_ownership, Configuration *conf, CryptoBackend *crypto, NetworkBackend *network)
CDocReader *createReader(const std::string&amp; path, Configuration *conf, CryptoBackend *crypto, NetworkBackend *network)
CDocReader *createReader(std::istream&amp; ifs, Configuration *conf, CryptoBackend *crypto, NetworkBackend *network)
</pre><p> CryptoBackend has to be supplied, NetworkBackend and Configuration may be nullptr if keyserver is not used. CDocReader does not take ownership of these objects, so they should be deleted by caller.</p>
<p>The list of locks in file can be obtained by method: </p><pre class="fragment">const std::vector&lt;Lock&gt; getLocks()
</pre><p> The order of locks is the same as in CDoc container and the 0-based index is used to refer to the lock in decryption methods.</p>
<p>As a convenience method, a public-key lock can be looked up by a certificate (der-encoded): </p><pre class="fragment">result_t getLockForCert(const std::vector&lt;uint8_t&gt;&amp; cert)
</pre><p> It return the index of a lock that can be opened by the private key of the certificate or negative number if not found.</p>
<p>Once the correct lock is chosen, the FMK (File Master Key) of the container has to be obtained: </p><pre class="fragment">result_t getFMK(std::vector&lt;uint8_t&gt;&amp; fmk, unsigned int lock_idx)
</pre><p> Depending on the lock type this calls relevant methods of CryptoBackend (and NetworkBackend) implementation to obtain and decrypt FMK.</p>
<p>Then the FMK can be used to start the encryption: </p><pre class="fragment">result_t beginDecryption(const std::vector&lt;uint8_t&gt;&amp; fmk)
</pre><p> Individual files can be read by nextFile: </p><pre class="fragment">result_t nextFile(std::string&amp; name, int64_t&amp; size)
</pre><p> It return the name and size of the next file in encrypted stream, or END_OF_STREAM if there are no more files. Due to the structure of CDoc container, files have to be processed sequentially - there is no way to rewind the stream. The name returned is the <em>exact filename</em> in encrypted stream. If the application intends to save the file with the same name, it has to verify that the path is safe.</p>
<p>The actual decrypted data can be read with method: </p><pre class="fragment">result_t readData(uint8_t *dst, size_t size)
</pre><p> This reads the data from current file.</p>
<p>When all files are read, the finalizer has to be called: </p><pre class="fragment">result_t finishDecryption()
</pre><p> The decrypted data should <em>not be used</em> before successful finalization because it performs the final check of data integrity. If it fails, the data should be assumed incomplete or corrupted.</p>
<h2><a class="anchor" id="autotoc_md13"></a>
TLDR</h2>
<pre class="fragment">struct MyBackend : public libcdoc::CryptoBackend {
    /* Elliptic curves */
    result_t deriveECDH1(std::vector&lt;uint8_t&gt;&amp; dst, const std::vector&lt;uint8_t&gt; &amp;public_key, unsigned int idx) override final {
        /* Derive shared secret and write to dst */
    }
    /* RSA */
    result_t decryptRSA(std::vector&lt;uint8_t&gt;&amp; dst, const std::vector&lt;uint8_t&gt;&amp; data, bool oaep, unsigned int idx) override final {
        /* Decrypt data and write to dst */
    }
    /* Only needed for symmetric keys */
    int getSecret(std::vector&lt;uint8_t&gt;&amp; dst, unsigned int idx) override final {
        /* Write secret to dst */
    }
}

/* In the data processing method */
MyBackend crypto;

CDocReader *reader = createReader(cdoc_filename, nullptr, &amp;crypto, nullptr);
/* Get list of locks */
auto locks = reader-&gt;getLocks();
/* Choose a lock that you have a key for, then decrypt FMK */
std::vector&lt;uint8_t&gt; fmk;
reader-&gt;getFMK(fmk, lock_idx);
/* Start decryption */
reader-&gt;beginDecryption(const std::vector&lt;uint8_t&gt;&amp; fmk);
std::string name;
int64_t size;
while(reader-&gt;nextFile(name, size) == libcdoc::OK) {
    /* Allocate data buffer etc... */
    reader-&gt;readData(buffer, size);
}
/* Finish decryption */
reader-&gt;finishDecryption();

delete reader;
</pre> </div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Feb 12 2025 11:12:06 for libcdoc by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8 </li>
  </ul>
</div>
</body>
</html>
